/*
 * SibAccessNota_user.c
 *
 * Generated by nota-stubgen3.pl 3.0pre1
 *  Date: 24-5-2010 11:19:46
 *
 * Source: sib.xml
 *  Created: 24-5-2010 9:59:8
 *  Modified: 24-5-2010 9:59:8
 *  Accessed: 24-5-2010 11:19:46
 *
 * Stub adapter version 3.0
 *
 */


/* Stub header */
#include "SibAccessNota_user.h"
/* Internal platform specific header */
#include <stubgen/hin3_stubadapter_if.h>


/* Static array to send packets (of type _req, _cnf or _ind).
 * Size of an array is currently 2048, but can be optimize with
 * maximum size of packet len sent. */
#define STUB_SIBACCESSNOTAUSER_SENDBUFFER_SIZE 2048

static uint8_t nota_send_buffer[STUB_SIBACCESSNOTAUSER_SENDBUFFER_SIZE];

/* Prototypes for parser functions */
static skeleton_parser_function SibAccessNota_user_parse_signal_id( uint16_t function_id, uint16_t* param_count );
static int SibAccessNota_Join_cnf_parse( struct context_pointer* context, struct token* tokens, int tokens_count );
static int SibAccessNota_Insert_cnf_parse( struct context_pointer* context, struct token* tokens, int tokens_count );
static int SibAccessNota_Remove_cnf_parse( struct context_pointer* context, struct token* tokens, int tokens_count );
static int SibAccessNota_Update_cnf_parse( struct context_pointer* context, struct token* tokens, int tokens_count );
static int SibAccessNota_Query_cnf_parse( struct context_pointer* context, struct token* tokens, int tokens_count );
static int SibAccessNota_Subscribe_cnf_parse( struct context_pointer* context, struct token* tokens, int tokens_count );
static int SibAccessNota_Unsubscribe_cnf_parse( struct context_pointer* context, struct token* tokens, int tokens_count );
static int SibAccessNota_Leave_cnf_parse( struct context_pointer* context, struct token* tokens, int tokens_count );
static int SibAccessNota_Subscription_ind_parse( struct context_pointer* context, struct token* tokens, int tokens_count );
static int SibAccessNota_Unsubscribe_ind_parse( struct context_pointer* context, struct token* tokens, int tokens_count );
static int SibAccessNota_Leave_ind_parse( struct context_pointer* context, struct token* tokens, int tokens_count );

/* Parser function */
static skeleton_parser_function SibAccessNota_user_parse_signal_id( uint16_t function_id, uint16_t* param_count )
{
	switch( function_id )
	{
		case JOIN_CNF_SIGNAL_ID:
		{
			*param_count = JOIN_CNF_TOKEN_NUMBER;
			return SibAccessNota_Join_cnf_parse;
		}
		case INSERT_CNF_SIGNAL_ID:
		{
			*param_count = INSERT_CNF_TOKEN_NUMBER;
			return SibAccessNota_Insert_cnf_parse;
		}
		case REMOVE_CNF_SIGNAL_ID:
		{
			*param_count = REMOVE_CNF_TOKEN_NUMBER;
			return SibAccessNota_Remove_cnf_parse;
		}
		case UPDATE_CNF_SIGNAL_ID:
		{
			*param_count = UPDATE_CNF_TOKEN_NUMBER;
			return SibAccessNota_Update_cnf_parse;
		}
		case QUERY_CNF_SIGNAL_ID:
		{
			*param_count = QUERY_CNF_TOKEN_NUMBER;
			return SibAccessNota_Query_cnf_parse;
		}
		case SUBSCRIBE_CNF_SIGNAL_ID:
		{
			*param_count = SUBSCRIBE_CNF_TOKEN_NUMBER;
			return SibAccessNota_Subscribe_cnf_parse;
		}
		case UNSUBSCRIBE_CNF_SIGNAL_ID:
		{
			*param_count = UNSUBSCRIBE_CNF_TOKEN_NUMBER;
			return SibAccessNota_Unsubscribe_cnf_parse;
		}
		case LEAVE_CNF_SIGNAL_ID:
		{
			*param_count = LEAVE_CNF_TOKEN_NUMBER;
			return SibAccessNota_Leave_cnf_parse;
		}
		case SUBSCRIPTION_IND_SIGNAL_ID:
		{
			*param_count = SUBSCRIPTION_IND_TOKEN_NUMBER;
			return SibAccessNota_Subscription_ind_parse;
		}
		case UNSUBSCRIBE_IND_SIGNAL_ID:
		{
			*param_count = UNSUBSCRIBE_IND_TOKEN_NUMBER;
			return SibAccessNota_Unsubscribe_ind_parse;
		}
		case LEAVE_IND_SIGNAL_ID:
		{
			*param_count = LEAVE_IND_TOKEN_NUMBER;
			return SibAccessNota_Leave_ind_parse;
		}
		default:
			return NULL;
	}
}

int SibAccessNota_user_new_connection( struct context_pointer* context )
{
	/* call to platform support library */
	return nota_stub_add_new_connection( context, SibAccessNota_user_parse_signal_id, SibAccessNota_user_handler_error, SibAccessNota_user_handler_disconnected );
}


int SibAccessNota_user_remove_connection( struct context_pointer* context )
{
	/* call to platform support library */
	return nota_stub_remove_connection( context );
}


int SibAccessNota_Join_req( struct context_pointer* context, uint8_t* nodeid, uint16_t nodeid_len, uint8_t* spaceid, uint16_t spaceid_len, uint32_t msgnum, uint8_t* credentials, uint16_t credentials_len )
{
	int ret = 0;
	uint8_t* buf = 0;
	uint16_t id = JOIN_REQ_SIGNAL_ID;
	int packet_len = 3;
	int partial_packet_sent = 0;
	int added_bytes = 0;

	/* Calculate packet size */
	packet_len += 1 + nota_stub_calculate_binary_token_length( nodeid_len );
	packet_len += 1 + nota_stub_calculate_binary_token_length( spaceid_len );
	packet_len += 1 + nota_stub_calculate_binary_token_length( credentials_len );
	packet_len += JOIN_REQ_PACKET_LENGTH;

	buf = &nota_send_buffer[0];

	/* Signal id */
	buf[added_bytes++]=TOKEN_SIGNAL16;
	NOTA_STUB_PACK16( &buf[added_bytes], id );
	added_bytes += 2;

	/* Packaging the values of the parameters into the buffer */
	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,nodeid,nodeid_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( nodeid_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,spaceid,spaceid_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( spaceid_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	buf[added_bytes++] = TOKEN_UINT32_T;
	NOTA_STUB_PACK32( &buf[added_bytes], msgnum );
	added_bytes += 4;

	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,credentials,credentials_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( credentials_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	/* Send the buffer via the active socket */
	if ( packet_len > 0 )
	{
		ret = nota_stub_send_message( context, ( char* )buf, packet_len );
	}

	return ret;
}


int SibAccessNota_Insert_req( struct context_pointer* context, uint8_t* nodeid, uint16_t nodeid_len, uint8_t* spaceid, uint16_t spaceid_len, uint32_t msgnum, encoding_t encoding, uint8_t* insert_graph, uint16_t insert_graph_len, confirm_t confirm )
{
	int ret = 0;
	uint8_t* buf = 0;
	uint16_t id = INSERT_REQ_SIGNAL_ID;
	int packet_len = 3;
	int partial_packet_sent = 0;
	int added_bytes = 0;

	/* Calculate packet size */
	packet_len += 1 + nota_stub_calculate_binary_token_length( nodeid_len );
	packet_len += 1 + nota_stub_calculate_binary_token_length( spaceid_len );
	packet_len += 1 + nota_stub_calculate_binary_token_length( insert_graph_len );
	packet_len += INSERT_REQ_PACKET_LENGTH;

	buf = &nota_send_buffer[0];

	/* Signal id */
	buf[added_bytes++]=TOKEN_SIGNAL16;
	NOTA_STUB_PACK16( &buf[added_bytes], id );
	added_bytes += 2;

	/* Packaging the values of the parameters into the buffer */
	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,nodeid,nodeid_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( nodeid_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,spaceid,spaceid_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( spaceid_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	buf[added_bytes++] = TOKEN_UINT32_T;
	NOTA_STUB_PACK32( &buf[added_bytes], msgnum );
	added_bytes += 4;

	buf[added_bytes++] = TOKEN_UINT32_T;
	NOTA_STUB_PACK32( &buf[added_bytes], encoding );
	added_bytes += 4;

	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,insert_graph,insert_graph_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( insert_graph_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	buf[added_bytes++] = TOKEN_UINT32_T;
	NOTA_STUB_PACK32( &buf[added_bytes], confirm );
	added_bytes += 4;

	/* Send the buffer via the active socket */
	if ( packet_len > 0 )
	{
		ret = nota_stub_send_message( context, ( char* )buf, packet_len );
	}

	return ret;
}


int SibAccessNota_Remove_req( struct context_pointer* context, uint8_t* nodeid, uint16_t nodeid_len, uint8_t* spaceid, uint16_t spaceid_len, uint32_t msgnum, encoding_t encoding, uint8_t* remove_graph, uint16_t remove_graph_len, confirm_t confirm )
{
	int ret = 0;
	uint8_t* buf = 0;
	uint16_t id = REMOVE_REQ_SIGNAL_ID;
	int packet_len = 3;
	int partial_packet_sent = 0;
	int added_bytes = 0;

	/* Calculate packet size */
	packet_len += 1 + nota_stub_calculate_binary_token_length( nodeid_len );
	packet_len += 1 + nota_stub_calculate_binary_token_length( spaceid_len );
	packet_len += 1 + nota_stub_calculate_binary_token_length( remove_graph_len );
	packet_len += REMOVE_REQ_PACKET_LENGTH;

	buf = &nota_send_buffer[0];

	/* Signal id */
	buf[added_bytes++]=TOKEN_SIGNAL16;
	NOTA_STUB_PACK16( &buf[added_bytes], id );
	added_bytes += 2;

	/* Packaging the values of the parameters into the buffer */
	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,nodeid,nodeid_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( nodeid_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,spaceid,spaceid_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( spaceid_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	buf[added_bytes++] = TOKEN_UINT32_T;
	NOTA_STUB_PACK32( &buf[added_bytes], msgnum );
	added_bytes += 4;

	buf[added_bytes++] = TOKEN_UINT32_T;
	NOTA_STUB_PACK32( &buf[added_bytes], encoding );
	added_bytes += 4;

	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,remove_graph,remove_graph_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( remove_graph_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	buf[added_bytes++] = TOKEN_UINT32_T;
	NOTA_STUB_PACK32( &buf[added_bytes], confirm );
	added_bytes += 4;

	/* Send the buffer via the active socket */
	if ( packet_len > 0 )
	{
		ret = nota_stub_send_message( context, ( char* )buf, packet_len );
	}

	return ret;
}


int SibAccessNota_Update_req( struct context_pointer* context, uint8_t* nodeid, uint16_t nodeid_len, uint8_t* spaceid, uint16_t spaceid_len, uint32_t msgnum, encoding_t encoding, uint8_t* insert_graph, uint16_t insert_graph_len, uint8_t* remove_graph, uint16_t remove_graph_len, confirm_t confirm )
{
	int ret = 0;
	uint8_t* buf = 0;
	uint16_t id = UPDATE_REQ_SIGNAL_ID;
	int packet_len = 3;
	int partial_packet_sent = 0;
	int added_bytes = 0;

	/* Calculate packet size */
	packet_len += 1 + nota_stub_calculate_binary_token_length( nodeid_len );
	packet_len += 1 + nota_stub_calculate_binary_token_length( spaceid_len );
	packet_len += 1 + nota_stub_calculate_binary_token_length( insert_graph_len );
	packet_len += 1 + nota_stub_calculate_binary_token_length( remove_graph_len );
	packet_len += UPDATE_REQ_PACKET_LENGTH;

	buf = &nota_send_buffer[0];

	/* Signal id */
	buf[added_bytes++]=TOKEN_SIGNAL16;
	NOTA_STUB_PACK16( &buf[added_bytes], id );
	added_bytes += 2;

	/* Packaging the values of the parameters into the buffer */
	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,nodeid,nodeid_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( nodeid_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,spaceid,spaceid_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( spaceid_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	buf[added_bytes++] = TOKEN_UINT32_T;
	NOTA_STUB_PACK32( &buf[added_bytes], msgnum );
	added_bytes += 4;

	buf[added_bytes++] = TOKEN_UINT32_T;
	NOTA_STUB_PACK32( &buf[added_bytes], encoding );
	added_bytes += 4;

	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,insert_graph,insert_graph_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( insert_graph_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,remove_graph,remove_graph_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( remove_graph_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	buf[added_bytes++] = TOKEN_UINT32_T;
	NOTA_STUB_PACK32( &buf[added_bytes], confirm );
	added_bytes += 4;

	/* Send the buffer via the active socket */
	if ( packet_len > 0 )
	{
		ret = nota_stub_send_message( context, ( char* )buf, packet_len );
	}

	return ret;
}


int SibAccessNota_Query_req( struct context_pointer* context, uint8_t* nodeid, uint16_t nodeid_len, uint8_t* spaceid, uint16_t spaceid_len, uint32_t msgnum, query_format_t format, uint8_t* query, uint16_t query_len, confirm_t confirm )
{
	int ret = 0;
	uint8_t* buf = 0;
	uint16_t id = QUERY_REQ_SIGNAL_ID;
	int packet_len = 3;
	int partial_packet_sent = 0;
	int added_bytes = 0;

	/* Calculate packet size */
	packet_len += 1 + nota_stub_calculate_binary_token_length( nodeid_len );
	packet_len += 1 + nota_stub_calculate_binary_token_length( spaceid_len );
	packet_len += 1 + nota_stub_calculate_binary_token_length( query_len );
	packet_len += QUERY_REQ_PACKET_LENGTH;

	buf = &nota_send_buffer[0];

	/* Signal id */
	buf[added_bytes++]=TOKEN_SIGNAL16;
	NOTA_STUB_PACK16( &buf[added_bytes], id );
	added_bytes += 2;

	/* Packaging the values of the parameters into the buffer */
	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,nodeid,nodeid_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( nodeid_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,spaceid,spaceid_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( spaceid_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	buf[added_bytes++] = TOKEN_UINT32_T;
	NOTA_STUB_PACK32( &buf[added_bytes], msgnum );
	added_bytes += 4;

	buf[added_bytes++] = TOKEN_UINT32_T;
	NOTA_STUB_PACK32( &buf[added_bytes], format );
	added_bytes += 4;

	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,query,query_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( query_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	buf[added_bytes++] = TOKEN_UINT32_T;
	NOTA_STUB_PACK32( &buf[added_bytes], confirm );
	added_bytes += 4;

	/* Send the buffer via the active socket */
	if ( packet_len > 0 )
	{
		ret = nota_stub_send_message( context, ( char* )buf, packet_len );
	}

	return ret;
}


int SibAccessNota_Subscribe_req( struct context_pointer* context, uint8_t* nodeid, uint16_t nodeid_len, uint8_t* spaceid, uint16_t spaceid_len, uint32_t msgnum, query_format_t format, uint8_t* query, uint16_t query_len, confirm_t results )
{
	int ret = 0;
	uint8_t* buf = 0;
	uint16_t id = SUBSCRIBE_REQ_SIGNAL_ID;
	int packet_len = 3;
	int partial_packet_sent = 0;
	int added_bytes = 0;

	/* Calculate packet size */
	packet_len += 1 + nota_stub_calculate_binary_token_length( nodeid_len );
	packet_len += 1 + nota_stub_calculate_binary_token_length( spaceid_len );
	packet_len += 1 + nota_stub_calculate_binary_token_length( query_len );
	packet_len += SUBSCRIBE_REQ_PACKET_LENGTH;

	buf = &nota_send_buffer[0];

	/* Signal id */
	buf[added_bytes++]=TOKEN_SIGNAL16;
	NOTA_STUB_PACK16( &buf[added_bytes], id );
	added_bytes += 2;

	/* Packaging the values of the parameters into the buffer */
	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,nodeid,nodeid_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( nodeid_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,spaceid,spaceid_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( spaceid_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	buf[added_bytes++] = TOKEN_UINT32_T;
	NOTA_STUB_PACK32( &buf[added_bytes], msgnum );
	added_bytes += 4;

	buf[added_bytes++] = TOKEN_UINT32_T;
	NOTA_STUB_PACK32( &buf[added_bytes], format );
	added_bytes += 4;

	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,query,query_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( query_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	buf[added_bytes++] = TOKEN_UINT32_T;
	NOTA_STUB_PACK32( &buf[added_bytes], results );
	added_bytes += 4;

	/* Send the buffer via the active socket */
	if ( packet_len > 0 )
	{
		ret = nota_stub_send_message( context, ( char* )buf, packet_len );
	}

	return ret;
}


int SibAccessNota_Unsubscribe_req( struct context_pointer* context, uint8_t* nodeid, uint16_t nodeid_len, uint8_t* spaceid, uint16_t spaceid_len, uint32_t msgnum, uint8_t* subscription_id, uint16_t subscription_id_len )
{
	int ret = 0;
	uint8_t* buf = 0;
	uint16_t id = UNSUBSCRIBE_REQ_SIGNAL_ID;
	int packet_len = 3;
	int partial_packet_sent = 0;
	int added_bytes = 0;

	/* Calculate packet size */
	packet_len += 1 + nota_stub_calculate_binary_token_length( nodeid_len );
	packet_len += 1 + nota_stub_calculate_binary_token_length( spaceid_len );
	packet_len += 1 + nota_stub_calculate_binary_token_length( subscription_id_len );
	packet_len += UNSUBSCRIBE_REQ_PACKET_LENGTH;

	buf = &nota_send_buffer[0];

	/* Signal id */
	buf[added_bytes++]=TOKEN_SIGNAL16;
	NOTA_STUB_PACK16( &buf[added_bytes], id );
	added_bytes += 2;

	/* Packaging the values of the parameters into the buffer */
	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,nodeid,nodeid_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( nodeid_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,spaceid,spaceid_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( spaceid_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	buf[added_bytes++] = TOKEN_UINT32_T;
	NOTA_STUB_PACK32( &buf[added_bytes], msgnum );
	added_bytes += 4;

	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,subscription_id,subscription_id_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( subscription_id_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	/* Send the buffer via the active socket */
	if ( packet_len > 0 )
	{
		ret = nota_stub_send_message( context, ( char* )buf, packet_len );
	}

	return ret;
}


int SibAccessNota_Leave_req( struct context_pointer* context, uint8_t* nodeid, uint16_t nodeid_len, uint8_t* spaceid, uint16_t spaceid_len, uint32_t msgnum )
{
	int ret = 0;
	uint8_t* buf = 0;
	uint16_t id = LEAVE_REQ_SIGNAL_ID;
	int packet_len = 3;
	int partial_packet_sent = 0;
	int added_bytes = 0;

	/* Calculate packet size */
	packet_len += 1 + nota_stub_calculate_binary_token_length( nodeid_len );
	packet_len += 1 + nota_stub_calculate_binary_token_length( spaceid_len );
	packet_len += LEAVE_REQ_PACKET_LENGTH;

	buf = &nota_send_buffer[0];

	/* Signal id */
	buf[added_bytes++]=TOKEN_SIGNAL16;
	NOTA_STUB_PACK16( &buf[added_bytes], id );
	added_bytes += 2;

	/* Packaging the values of the parameters into the buffer */
	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,nodeid,nodeid_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( nodeid_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,spaceid,spaceid_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( spaceid_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	buf[added_bytes++] = TOKEN_UINT32_T;
	NOTA_STUB_PACK32( &buf[added_bytes], msgnum );
	added_bytes += 4;

	/* Send the buffer via the active socket */
	if ( packet_len > 0 )
	{
		ret = nota_stub_send_message( context, ( char* )buf, packet_len );
	}

	return ret;
}


static int SibAccessNota_Join_cnf_parse( struct context_pointer* context, struct token* tokens, int tokens_count )
{
	int ret = 0;

	NOTA_STUB_ASSERT( tokens_count == JOIN_CNF_TOKEN_NUMBER );

	/* Validate tokens */
	if ( !( ( tokens[0].type == TOKEN_BDATA8 ) || ( tokens[0].type == TOKEN_BDATA16 ) || ( tokens[0].type == TOKEN_NULL ) ) )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( !( ( tokens[1].type == TOKEN_BDATA8 ) || ( tokens[1].type == TOKEN_BDATA16 ) || ( tokens[1].type == TOKEN_NULL ) ) )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( tokens[2].type != TOKEN_UINT32_T )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( tokens[3].type != TOKEN_UINT32_T )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( !( ( tokens[4].type == TOKEN_BDATA8 ) || ( tokens[4].type == TOKEN_BDATA16 ) || ( tokens[4].type == TOKEN_NULL ) ) )
	{
		ret = -1;
		goto finishparsing;
	}

	/* Allocate memory for variables */

	/* Unpack values from the tokens into variables */
 
	/* Call user implemented process method */
	SibAccessNota_Join_cnf_process( context, tokens[0].type == TOKEN_NULL ? NULL : tokens[0].data.bdata.ptr, tokens[0].type == TOKEN_NULL ? 0 : tokens[0].data.bdata.len, tokens[1].type == TOKEN_NULL ? NULL : tokens[1].data.bdata.ptr, tokens[1].type == TOKEN_NULL ? 0 : tokens[1].data.bdata.len, tokens[2].data.uint32_t, ( sibstatus_t )tokens[3].data.uint32_t, tokens[4].type == TOKEN_NULL ? NULL : tokens[4].data.bdata.ptr, tokens[4].type == TOKEN_NULL ? 0 : tokens[4].data.bdata.len );

	/* Postprocess release temporary allocated memory */

	/* Handle possible errors */
finishparsing:

	return ret;
}

static int SibAccessNota_Insert_cnf_parse( struct context_pointer* context, struct token* tokens, int tokens_count )
{
	int ret = 0;

	NOTA_STUB_ASSERT( tokens_count == INSERT_CNF_TOKEN_NUMBER );

	/* Validate tokens */
	if ( !( ( tokens[0].type == TOKEN_BDATA8 ) || ( tokens[0].type == TOKEN_BDATA16 ) || ( tokens[0].type == TOKEN_NULL ) ) )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( !( ( tokens[1].type == TOKEN_BDATA8 ) || ( tokens[1].type == TOKEN_BDATA16 ) || ( tokens[1].type == TOKEN_NULL ) ) )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( tokens[2].type != TOKEN_UINT32_T )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( tokens[3].type != TOKEN_UINT32_T )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( !( ( tokens[4].type == TOKEN_BDATA8 ) || ( tokens[4].type == TOKEN_BDATA16 ) || ( tokens[4].type == TOKEN_NULL ) ) )
	{
		ret = -1;
		goto finishparsing;
	}

	/* Allocate memory for variables */

	/* Unpack values from the tokens into variables */
 
	/* Call user implemented process method */
	SibAccessNota_Insert_cnf_process( context, tokens[0].type == TOKEN_NULL ? NULL : tokens[0].data.bdata.ptr, tokens[0].type == TOKEN_NULL ? 0 : tokens[0].data.bdata.len, tokens[1].type == TOKEN_NULL ? NULL : tokens[1].data.bdata.ptr, tokens[1].type == TOKEN_NULL ? 0 : tokens[1].data.bdata.len, tokens[2].data.uint32_t, ( sibstatus_t )tokens[3].data.uint32_t, tokens[4].type == TOKEN_NULL ? NULL : tokens[4].data.bdata.ptr, tokens[4].type == TOKEN_NULL ? 0 : tokens[4].data.bdata.len );

	/* Postprocess release temporary allocated memory */

	/* Handle possible errors */
finishparsing:

	return ret;
}

static int SibAccessNota_Remove_cnf_parse( struct context_pointer* context, struct token* tokens, int tokens_count )
{
	int ret = 0;

	NOTA_STUB_ASSERT( tokens_count == REMOVE_CNF_TOKEN_NUMBER );

	/* Validate tokens */
	if ( !( ( tokens[0].type == TOKEN_BDATA8 ) || ( tokens[0].type == TOKEN_BDATA16 ) || ( tokens[0].type == TOKEN_NULL ) ) )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( !( ( tokens[1].type == TOKEN_BDATA8 ) || ( tokens[1].type == TOKEN_BDATA16 ) || ( tokens[1].type == TOKEN_NULL ) ) )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( tokens[2].type != TOKEN_UINT32_T )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( tokens[3].type != TOKEN_UINT32_T )
	{
		ret = -1;
		goto finishparsing;
	}

	/* Allocate memory for variables */

	/* Unpack values from the tokens into variables */
 
	/* Call user implemented process method */
	SibAccessNota_Remove_cnf_process( context, tokens[0].type == TOKEN_NULL ? NULL : tokens[0].data.bdata.ptr, tokens[0].type == TOKEN_NULL ? 0 : tokens[0].data.bdata.len, tokens[1].type == TOKEN_NULL ? NULL : tokens[1].data.bdata.ptr, tokens[1].type == TOKEN_NULL ? 0 : tokens[1].data.bdata.len, tokens[2].data.uint32_t, ( sibstatus_t )tokens[3].data.uint32_t );

	/* Postprocess release temporary allocated memory */

	/* Handle possible errors */
finishparsing:

	return ret;
}

static int SibAccessNota_Update_cnf_parse( struct context_pointer* context, struct token* tokens, int tokens_count )
{
	int ret = 0;

	NOTA_STUB_ASSERT( tokens_count == UPDATE_CNF_TOKEN_NUMBER );

	/* Validate tokens */
	if ( !( ( tokens[0].type == TOKEN_BDATA8 ) || ( tokens[0].type == TOKEN_BDATA16 ) || ( tokens[0].type == TOKEN_NULL ) ) )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( !( ( tokens[1].type == TOKEN_BDATA8 ) || ( tokens[1].type == TOKEN_BDATA16 ) || ( tokens[1].type == TOKEN_NULL ) ) )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( tokens[2].type != TOKEN_UINT32_T )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( tokens[3].type != TOKEN_UINT32_T )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( !( ( tokens[4].type == TOKEN_BDATA8 ) || ( tokens[4].type == TOKEN_BDATA16 ) || ( tokens[4].type == TOKEN_NULL ) ) )
	{
		ret = -1;
		goto finishparsing;
	}

	/* Allocate memory for variables */

	/* Unpack values from the tokens into variables */
 
	/* Call user implemented process method */
	SibAccessNota_Update_cnf_process( context, tokens[0].type == TOKEN_NULL ? NULL : tokens[0].data.bdata.ptr, tokens[0].type == TOKEN_NULL ? 0 : tokens[0].data.bdata.len, tokens[1].type == TOKEN_NULL ? NULL : tokens[1].data.bdata.ptr, tokens[1].type == TOKEN_NULL ? 0 : tokens[1].data.bdata.len, tokens[2].data.uint32_t, ( sibstatus_t )tokens[3].data.uint32_t, tokens[4].type == TOKEN_NULL ? NULL : tokens[4].data.bdata.ptr, tokens[4].type == TOKEN_NULL ? 0 : tokens[4].data.bdata.len );

	/* Postprocess release temporary allocated memory */

	/* Handle possible errors */
finishparsing:

	return ret;
}

static int SibAccessNota_Query_cnf_parse( struct context_pointer* context, struct token* tokens, int tokens_count )
{
	int ret = 0;

	NOTA_STUB_ASSERT( tokens_count == QUERY_CNF_TOKEN_NUMBER );

	/* Validate tokens */
	if ( !( ( tokens[0].type == TOKEN_BDATA8 ) || ( tokens[0].type == TOKEN_BDATA16 ) || ( tokens[0].type == TOKEN_NULL ) ) )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( !( ( tokens[1].type == TOKEN_BDATA8 ) || ( tokens[1].type == TOKEN_BDATA16 ) || ( tokens[1].type == TOKEN_NULL ) ) )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( tokens[2].type != TOKEN_UINT32_T )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( tokens[3].type != TOKEN_UINT32_T )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( !( ( tokens[4].type == TOKEN_BDATA8 ) || ( tokens[4].type == TOKEN_BDATA16 ) || ( tokens[4].type == TOKEN_NULL ) ) )
	{
		ret = -1;
		goto finishparsing;
	}

	/* Allocate memory for variables */

	/* Unpack values from the tokens into variables */
 
	/* Call user implemented process method */
	SibAccessNota_Query_cnf_process( context, tokens[0].type == TOKEN_NULL ? NULL : tokens[0].data.bdata.ptr, tokens[0].type == TOKEN_NULL ? 0 : tokens[0].data.bdata.len, tokens[1].type == TOKEN_NULL ? NULL : tokens[1].data.bdata.ptr, tokens[1].type == TOKEN_NULL ? 0 : tokens[1].data.bdata.len, tokens[2].data.uint32_t, ( sibstatus_t )tokens[3].data.uint32_t, tokens[4].type == TOKEN_NULL ? NULL : tokens[4].data.bdata.ptr, tokens[4].type == TOKEN_NULL ? 0 : tokens[4].data.bdata.len );

	/* Postprocess release temporary allocated memory */

	/* Handle possible errors */
finishparsing:

	return ret;
}

static int SibAccessNota_Subscribe_cnf_parse( struct context_pointer* context, struct token* tokens, int tokens_count )
{
	int ret = 0;

	NOTA_STUB_ASSERT( tokens_count == SUBSCRIBE_CNF_TOKEN_NUMBER );

	/* Validate tokens */
	if ( !( ( tokens[0].type == TOKEN_BDATA8 ) || ( tokens[0].type == TOKEN_BDATA16 ) || ( tokens[0].type == TOKEN_NULL ) ) )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( !( ( tokens[1].type == TOKEN_BDATA8 ) || ( tokens[1].type == TOKEN_BDATA16 ) || ( tokens[1].type == TOKEN_NULL ) ) )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( tokens[2].type != TOKEN_UINT32_T )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( tokens[3].type != TOKEN_UINT32_T )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( !( ( tokens[4].type == TOKEN_BDATA8 ) || ( tokens[4].type == TOKEN_BDATA16 ) || ( tokens[4].type == TOKEN_NULL ) ) )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( !( ( tokens[5].type == TOKEN_BDATA8 ) || ( tokens[5].type == TOKEN_BDATA16 ) || ( tokens[5].type == TOKEN_NULL ) ) )
	{
		ret = -1;
		goto finishparsing;
	}

	/* Allocate memory for variables */

	/* Unpack values from the tokens into variables */
 
	/* Call user implemented process method */
	SibAccessNota_Subscribe_cnf_process( context, tokens[0].type == TOKEN_NULL ? NULL : tokens[0].data.bdata.ptr, tokens[0].type == TOKEN_NULL ? 0 : tokens[0].data.bdata.len, tokens[1].type == TOKEN_NULL ? NULL : tokens[1].data.bdata.ptr, tokens[1].type == TOKEN_NULL ? 0 : tokens[1].data.bdata.len, tokens[2].data.uint32_t, ( sibstatus_t )tokens[3].data.uint32_t, tokens[4].type == TOKEN_NULL ? NULL : tokens[4].data.bdata.ptr, tokens[4].type == TOKEN_NULL ? 0 : tokens[4].data.bdata.len, tokens[5].type == TOKEN_NULL ? NULL : tokens[5].data.bdata.ptr, tokens[5].type == TOKEN_NULL ? 0 : tokens[5].data.bdata.len );

	/* Postprocess release temporary allocated memory */

	/* Handle possible errors */
finishparsing:

	return ret;
}

static int SibAccessNota_Unsubscribe_cnf_parse( struct context_pointer* context, struct token* tokens, int tokens_count )
{
	int ret = 0;

	NOTA_STUB_ASSERT( tokens_count == UNSUBSCRIBE_CNF_TOKEN_NUMBER );

	/* Validate tokens */
	if ( !( ( tokens[0].type == TOKEN_BDATA8 ) || ( tokens[0].type == TOKEN_BDATA16 ) || ( tokens[0].type == TOKEN_NULL ) ) )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( !( ( tokens[1].type == TOKEN_BDATA8 ) || ( tokens[1].type == TOKEN_BDATA16 ) || ( tokens[1].type == TOKEN_NULL ) ) )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( tokens[2].type != TOKEN_UINT32_T )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( tokens[3].type != TOKEN_UINT32_T )
	{
		ret = -1;
		goto finishparsing;
	}

	/* Allocate memory for variables */

	/* Unpack values from the tokens into variables */
 
	/* Call user implemented process method */
	SibAccessNota_Unsubscribe_cnf_process( context, tokens[0].type == TOKEN_NULL ? NULL : tokens[0].data.bdata.ptr, tokens[0].type == TOKEN_NULL ? 0 : tokens[0].data.bdata.len, tokens[1].type == TOKEN_NULL ? NULL : tokens[1].data.bdata.ptr, tokens[1].type == TOKEN_NULL ? 0 : tokens[1].data.bdata.len, tokens[2].data.uint32_t, ( sibstatus_t )tokens[3].data.uint32_t );

	/* Postprocess release temporary allocated memory */

	/* Handle possible errors */
finishparsing:

	return ret;
}

static int SibAccessNota_Leave_cnf_parse( struct context_pointer* context, struct token* tokens, int tokens_count )
{
	int ret = 0;

	NOTA_STUB_ASSERT( tokens_count == LEAVE_CNF_TOKEN_NUMBER );

	/* Validate tokens */
	if ( !( ( tokens[0].type == TOKEN_BDATA8 ) || ( tokens[0].type == TOKEN_BDATA16 ) || ( tokens[0].type == TOKEN_NULL ) ) )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( !( ( tokens[1].type == TOKEN_BDATA8 ) || ( tokens[1].type == TOKEN_BDATA16 ) || ( tokens[1].type == TOKEN_NULL ) ) )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( tokens[2].type != TOKEN_UINT32_T )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( tokens[3].type != TOKEN_UINT32_T )
	{
		ret = -1;
		goto finishparsing;
	}

	/* Allocate memory for variables */

	/* Unpack values from the tokens into variables */
 
	/* Call user implemented process method */
	SibAccessNota_Leave_cnf_process( context, tokens[0].type == TOKEN_NULL ? NULL : tokens[0].data.bdata.ptr, tokens[0].type == TOKEN_NULL ? 0 : tokens[0].data.bdata.len, tokens[1].type == TOKEN_NULL ? NULL : tokens[1].data.bdata.ptr, tokens[1].type == TOKEN_NULL ? 0 : tokens[1].data.bdata.len, tokens[2].data.uint32_t, ( sibstatus_t )tokens[3].data.uint32_t );

	/* Postprocess release temporary allocated memory */

	/* Handle possible errors */
finishparsing:

	return ret;
}

static int SibAccessNota_Subscription_ind_parse( struct context_pointer* context, struct token* tokens, int tokens_count )
{
	int ret = 0;

	NOTA_STUB_ASSERT( tokens_count == SUBSCRIPTION_IND_TOKEN_NUMBER );

	/* Validate tokens */
	if ( !( ( tokens[0].type == TOKEN_BDATA8 ) || ( tokens[0].type == TOKEN_BDATA16 ) || ( tokens[0].type == TOKEN_NULL ) ) )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( !( ( tokens[1].type == TOKEN_BDATA8 ) || ( tokens[1].type == TOKEN_BDATA16 ) || ( tokens[1].type == TOKEN_NULL ) ) )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( tokens[2].type != TOKEN_UINT32_T )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( tokens[3].type != TOKEN_UINT32_T )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( !( ( tokens[4].type == TOKEN_BDATA8 ) || ( tokens[4].type == TOKEN_BDATA16 ) || ( tokens[4].type == TOKEN_NULL ) ) )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( !( ( tokens[5].type == TOKEN_BDATA8 ) || ( tokens[5].type == TOKEN_BDATA16 ) || ( tokens[5].type == TOKEN_NULL ) ) )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( !( ( tokens[6].type == TOKEN_BDATA8 ) || ( tokens[6].type == TOKEN_BDATA16 ) || ( tokens[6].type == TOKEN_NULL ) ) )
	{
		ret = -1;
		goto finishparsing;
	}

	/* Allocate memory for variables */

	/* Unpack values from the tokens into variables */
 
	/* Call user implemented process method */
	SibAccessNota_Subscription_ind_process( context, tokens[0].type == TOKEN_NULL ? NULL : tokens[0].data.bdata.ptr, tokens[0].type == TOKEN_NULL ? 0 : tokens[0].data.bdata.len, tokens[1].type == TOKEN_NULL ? NULL : tokens[1].data.bdata.ptr, tokens[1].type == TOKEN_NULL ? 0 : tokens[1].data.bdata.len, tokens[2].data.uint32_t, tokens[3].data.uint32_t, tokens[4].type == TOKEN_NULL ? NULL : tokens[4].data.bdata.ptr, tokens[4].type == TOKEN_NULL ? 0 : tokens[4].data.bdata.len, tokens[5].type == TOKEN_NULL ? NULL : tokens[5].data.bdata.ptr, tokens[5].type == TOKEN_NULL ? 0 : tokens[5].data.bdata.len, tokens[6].type == TOKEN_NULL ? NULL : tokens[6].data.bdata.ptr, tokens[6].type == TOKEN_NULL ? 0 : tokens[6].data.bdata.len );

	/* Postprocess release temporary allocated memory */

	/* Handle possible errors */
finishparsing:

	return ret;
}

static int SibAccessNota_Unsubscribe_ind_parse( struct context_pointer* context, struct token* tokens, int tokens_count )
{
	int ret = 0;

	NOTA_STUB_ASSERT( tokens_count == UNSUBSCRIBE_IND_TOKEN_NUMBER );

	/* Validate tokens */
	if ( !( ( tokens[0].type == TOKEN_BDATA8 ) || ( tokens[0].type == TOKEN_BDATA16 ) || ( tokens[0].type == TOKEN_NULL ) ) )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( !( ( tokens[1].type == TOKEN_BDATA8 ) || ( tokens[1].type == TOKEN_BDATA16 ) || ( tokens[1].type == TOKEN_NULL ) ) )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( tokens[2].type != TOKEN_UINT32_T )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( tokens[3].type != TOKEN_UINT32_T )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( !( ( tokens[4].type == TOKEN_BDATA8 ) || ( tokens[4].type == TOKEN_BDATA16 ) || ( tokens[4].type == TOKEN_NULL ) ) )
	{
		ret = -1;
		goto finishparsing;
	}

	/* Allocate memory for variables */

	/* Unpack values from the tokens into variables */
 
	/* Call user implemented process method */
	SibAccessNota_Unsubscribe_ind_process( context, tokens[0].type == TOKEN_NULL ? NULL : tokens[0].data.bdata.ptr, tokens[0].type == TOKEN_NULL ? 0 : tokens[0].data.bdata.len, tokens[1].type == TOKEN_NULL ? NULL : tokens[1].data.bdata.ptr, tokens[1].type == TOKEN_NULL ? 0 : tokens[1].data.bdata.len, tokens[2].data.uint32_t, ( sibstatus_t )tokens[3].data.uint32_t, tokens[4].type == TOKEN_NULL ? NULL : tokens[4].data.bdata.ptr, tokens[4].type == TOKEN_NULL ? 0 : tokens[4].data.bdata.len );

	/* Postprocess release temporary allocated memory */

	/* Handle possible errors */
finishparsing:

	return ret;
}

static int SibAccessNota_Leave_ind_parse( struct context_pointer* context, struct token* tokens, int tokens_count )
{
	int ret = 0;

	NOTA_STUB_ASSERT( tokens_count == LEAVE_IND_TOKEN_NUMBER );

	/* Validate tokens */
	if ( !( ( tokens[0].type == TOKEN_BDATA8 ) || ( tokens[0].type == TOKEN_BDATA16 ) || ( tokens[0].type == TOKEN_NULL ) ) )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( !( ( tokens[1].type == TOKEN_BDATA8 ) || ( tokens[1].type == TOKEN_BDATA16 ) || ( tokens[1].type == TOKEN_NULL ) ) )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( tokens[2].type != TOKEN_UINT32_T )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( tokens[3].type != TOKEN_UINT32_T )
	{
		ret = -1;
		goto finishparsing;
	}

	/* Allocate memory for variables */

	/* Unpack values from the tokens into variables */
 
	/* Call user implemented process method */
	SibAccessNota_Leave_ind_process( context, tokens[0].type == TOKEN_NULL ? NULL : tokens[0].data.bdata.ptr, tokens[0].type == TOKEN_NULL ? 0 : tokens[0].data.bdata.len, tokens[1].type == TOKEN_NULL ? NULL : tokens[1].data.bdata.ptr, tokens[1].type == TOKEN_NULL ? 0 : tokens[1].data.bdata.len, tokens[2].data.uint32_t, ( sibstatus_t )tokens[3].data.uint32_t );

	/* Postprocess release temporary allocated memory */

	/* Handle possible errors */
finishparsing:

	return ret;
}

