/*
 * NoTA_System_ResourceMng_R01_01_user.c
 *
 * Generated by nota-stubgen3.pl 3.0pre1
 *  Date: 24-5-2010 11:19:46
 *
 * Source: NoTA_System_ResourceMng_R01_01_v03.xml
 *  Created: 24-5-2010 9:59:8
 *  Modified: 24-5-2010 9:59:8
 *  Accessed: 24-5-2010 11:19:46
 *
 * Stub adapter version 3.0
 *
 */


/* Stub header */
#include "NoTA_System_ResourceMng_R01_01_user.h"
/* Internal platform specific header */
#include <stubgen/hin3_stubadapter_if.h>


/* Static array to send packets (of type _req, _cnf or _ind).
 * Size of an array is currently 2048, but can be optimize with
 * maximum size of packet len sent. */
#define STUB_NOTA_SYSTEM_RESOURCEMNG_R01_01USER_SENDBUFFER_SIZE 2048

static uint8_t nota_send_buffer[STUB_NOTA_SYSTEM_RESOURCEMNG_R01_01USER_SENDBUFFER_SIZE];

/* Prototypes for parser functions */
static skeleton_parser_function NoTA_System_ResourceMng_R01_01_user_parse_signal_id( uint16_t function_id, uint16_t* param_count );
static int NoTA_System_ResourceMng_R01_01_Register_cnf_parse( struct context_pointer* context, struct token* tokens, int tokens_count );
static int NoTA_System_ResourceMng_R01_01_Deregister_cnf_parse( struct context_pointer* context, struct token* tokens, int tokens_count );
static int NoTA_System_ResourceMng_R01_01_Challenge_ind_parse( struct context_pointer* context, struct token* tokens, int tokens_count );
static int NoTA_System_ResourceMng_R01_01_ResolveService_cnf_parse( struct context_pointer* context, struct token* tokens, int tokens_count );
static int NoTA_System_ResourceMng_R01_01_ListOfServices_cnf_parse( struct context_pointer* context, struct token* tokens, int tokens_count );
static int NoTA_System_ResourceMng_R01_01_NewEvent_cnf_parse( struct context_pointer* context, struct token* tokens, int tokens_count );
static int NoTA_System_ResourceMng_R01_01_NewEvent_ind_parse( struct context_pointer* context, struct token* tokens, int tokens_count );
static int NoTA_System_ResourceMng_R01_01_DeleteEvent_cnf_parse( struct context_pointer* context, struct token* tokens, int tokens_count );

/* Parser function */
static skeleton_parser_function NoTA_System_ResourceMng_R01_01_user_parse_signal_id( uint16_t function_id, uint16_t* param_count )
{
	switch( function_id )
	{
		case REGISTER_CNF_SIGNAL_ID:
		{
			*param_count = REGISTER_CNF_TOKEN_NUMBER;
			return NoTA_System_ResourceMng_R01_01_Register_cnf_parse;
		}
		case DEREGISTER_CNF_SIGNAL_ID:
		{
			*param_count = DEREGISTER_CNF_TOKEN_NUMBER;
			return NoTA_System_ResourceMng_R01_01_Deregister_cnf_parse;
		}
		case CHALLENGE_IND_SIGNAL_ID:
		{
			*param_count = CHALLENGE_IND_TOKEN_NUMBER;
			return NoTA_System_ResourceMng_R01_01_Challenge_ind_parse;
		}
		case RESOLVESERVICE_CNF_SIGNAL_ID:
		{
			*param_count = RESOLVESERVICE_CNF_TOKEN_NUMBER;
			return NoTA_System_ResourceMng_R01_01_ResolveService_cnf_parse;
		}
		case LISTOFSERVICES_CNF_SIGNAL_ID:
		{
			*param_count = LISTOFSERVICES_CNF_TOKEN_NUMBER;
			return NoTA_System_ResourceMng_R01_01_ListOfServices_cnf_parse;
		}
		case NEWEVENT_CNF_SIGNAL_ID:
		{
			*param_count = NEWEVENT_CNF_TOKEN_NUMBER;
			return NoTA_System_ResourceMng_R01_01_NewEvent_cnf_parse;
		}
		case NEWEVENT_IND_SIGNAL_ID:
		{
			*param_count = NEWEVENT_IND_TOKEN_NUMBER;
			return NoTA_System_ResourceMng_R01_01_NewEvent_ind_parse;
		}
		case DELETEEVENT_CNF_SIGNAL_ID:
		{
			*param_count = DELETEEVENT_CNF_TOKEN_NUMBER;
			return NoTA_System_ResourceMng_R01_01_DeleteEvent_cnf_parse;
		}
		default:
			return NULL;
	}
}

int NoTA_System_ResourceMng_R01_01_user_new_connection( struct context_pointer* context )
{
	/* call to platform support library */
	return nota_stub_add_new_connection( context, NoTA_System_ResourceMng_R01_01_user_parse_signal_id, NoTA_System_ResourceMng_R01_01_user_handler_error, NoTA_System_ResourceMng_R01_01_user_handler_disconnected );
}


int NoTA_System_ResourceMng_R01_01_user_remove_connection( struct context_pointer* context )
{
	/* call to platform support library */
	return nota_stub_remove_connection( context );
}


int NoTA_System_ResourceMng_R01_01_Register_req( struct context_pointer* context, uint8_t* ontology_name, uint16_t ontology_name_len, uint8_t* service_desc, uint16_t service_desc_len, uint8_t* cert_reg, uint16_t cert_reg_len )
{
	int ret = 0;
	uint8_t* buf = 0;
	uint16_t id = REGISTER_REQ_SIGNAL_ID;
	int packet_len = 3;
	int partial_packet_sent = 0;
	int added_bytes = 0;

	/* Calculate packet size */
	packet_len += 1 + nota_stub_calculate_binary_token_length( ontology_name_len );
	packet_len += 1 + nota_stub_calculate_binary_token_length( service_desc_len );
	packet_len += 1 + nota_stub_calculate_binary_token_length( cert_reg_len );
	packet_len += REGISTER_REQ_PACKET_LENGTH;

	buf = &nota_send_buffer[0];

	/* Signal id */
	buf[added_bytes++]=TOKEN_SIGNAL16;
	NOTA_STUB_PACK16( &buf[added_bytes], id );
	added_bytes += 2;

	/* Packaging the values of the parameters into the buffer */
	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,ontology_name,ontology_name_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( ontology_name_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,service_desc,service_desc_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( service_desc_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,cert_reg,cert_reg_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( cert_reg_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	/* Send the buffer via the active socket */
	if ( packet_len > 0 )
	{
		ret = nota_stub_send_message( context, ( char* )buf, packet_len );
	}

	return ret;
}


int NoTA_System_ResourceMng_R01_01_Deregister_req( struct context_pointer* context, sid_t sid, uint8_t* certificate, uint16_t certificate_len )
{
	int ret = 0;
	uint8_t* buf = 0;
	uint16_t id = DEREGISTER_REQ_SIGNAL_ID;
	int packet_len = 3;
	int partial_packet_sent = 0;
	int added_bytes = 0;

	/* Calculate packet size */
	packet_len += 1 + nota_stub_calculate_binary_token_length( certificate_len );
	packet_len += DEREGISTER_REQ_PACKET_LENGTH;

	buf = &nota_send_buffer[0];

	/* Signal id */
	buf[added_bytes++]=TOKEN_SIGNAL16;
	NOTA_STUB_PACK16( &buf[added_bytes], id );
	added_bytes += 2;

	/* Packaging the values of the parameters into the buffer */
	buf[added_bytes++] = TOKEN_SID_T;
	NOTA_STUB_PACK32( &buf[added_bytes], sid );
	added_bytes += 4;

	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,certificate,certificate_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( certificate_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	/* Send the buffer via the active socket */
	if ( packet_len > 0 )
	{
		ret = nota_stub_send_message( context, ( char* )buf, packet_len );
	}

	return ret;
}


int NoTA_System_ResourceMng_R01_01_Challenge_rsp( struct context_pointer* context, uint8_t* challenge, uint16_t challenge_len )
{
	int ret = 0;
	uint8_t* buf = 0;
	uint16_t id = CHALLENGE_RSP_SIGNAL_ID;
	int packet_len = 3;
	int partial_packet_sent = 0;
	int added_bytes = 0;

	/* Calculate packet size */
	packet_len += 1 + nota_stub_calculate_binary_token_length( challenge_len );
	packet_len += CHALLENGE_RSP_PACKET_LENGTH;

	buf = &nota_send_buffer[0];

	/* Signal id */
	buf[added_bytes++]=TOKEN_SIGNAL16;
	NOTA_STUB_PACK16( &buf[added_bytes], id );
	added_bytes += 2;

	/* Packaging the values of the parameters into the buffer */
	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,challenge,challenge_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( challenge_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	/* Send the buffer via the active socket */
	if ( packet_len > 0 )
	{
		ret = nota_stub_send_message( context, ( char* )buf, packet_len );
	}

	return ret;
}


int NoTA_System_ResourceMng_R01_01_ResolveService_req( struct context_pointer* context, uint8_t* ontology_name, uint16_t ontology_name_len, uint8_t* service_desc, uint16_t service_desc_len )
{
	int ret = 0;
	uint8_t* buf = 0;
	uint16_t id = RESOLVESERVICE_REQ_SIGNAL_ID;
	int packet_len = 3;
	int partial_packet_sent = 0;
	int added_bytes = 0;

	/* Calculate packet size */
	packet_len += 1 + nota_stub_calculate_binary_token_length( ontology_name_len );
	packet_len += 1 + nota_stub_calculate_binary_token_length( service_desc_len );
	packet_len += RESOLVESERVICE_REQ_PACKET_LENGTH;

	buf = &nota_send_buffer[0];

	/* Signal id */
	buf[added_bytes++]=TOKEN_SIGNAL16;
	NOTA_STUB_PACK16( &buf[added_bytes], id );
	added_bytes += 2;

	/* Packaging the values of the parameters into the buffer */
	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,ontology_name,ontology_name_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( ontology_name_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,service_desc,service_desc_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( service_desc_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	/* Send the buffer via the active socket */
	if ( packet_len > 0 )
	{
		ret = nota_stub_send_message( context, ( char* )buf, packet_len );
	}

	return ret;
}


int NoTA_System_ResourceMng_R01_01_ListOfServices_req( struct context_pointer* context, uint8_t* ontology_name, uint16_t ontology_name_len )
{
	int ret = 0;
	uint8_t* buf = 0;
	uint16_t id = LISTOFSERVICES_REQ_SIGNAL_ID;
	int packet_len = 3;
	int partial_packet_sent = 0;
	int added_bytes = 0;

	/* Calculate packet size */
	packet_len += 1 + nota_stub_calculate_binary_token_length( ontology_name_len );
	packet_len += LISTOFSERVICES_REQ_PACKET_LENGTH;

	buf = &nota_send_buffer[0];

	/* Signal id */
	buf[added_bytes++]=TOKEN_SIGNAL16;
	NOTA_STUB_PACK16( &buf[added_bytes], id );
	added_bytes += 2;

	/* Packaging the values of the parameters into the buffer */
	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,ontology_name,ontology_name_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( ontology_name_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	/* Send the buffer via the active socket */
	if ( packet_len > 0 )
	{
		ret = nota_stub_send_message( context, ( char* )buf, packet_len );
	}

	return ret;
}


int NoTA_System_ResourceMng_R01_01_NewEvent_req( struct context_pointer* context, event_t event_t, uint8_t* ontology_name, uint16_t ontology_name_len, uint8_t* service_desc, uint16_t service_desc_len )
{
	int ret = 0;
	uint8_t* buf = 0;
	uint16_t id = NEWEVENT_REQ_SIGNAL_ID;
	int packet_len = 3;
	int partial_packet_sent = 0;
	int added_bytes = 0;

	/* Calculate packet size */
	packet_len += 1 + nota_stub_calculate_binary_token_length( ontology_name_len );
	packet_len += 1 + nota_stub_calculate_binary_token_length( service_desc_len );
	packet_len += NEWEVENT_REQ_PACKET_LENGTH;

	buf = &nota_send_buffer[0];

	/* Signal id */
	buf[added_bytes++]=TOKEN_SIGNAL16;
	NOTA_STUB_PACK16( &buf[added_bytes], id );
	added_bytes += 2;

	/* Packaging the values of the parameters into the buffer */
	buf[added_bytes++] = TOKEN_INT32_T;
	NOTA_STUB_PACK32( &buf[added_bytes], event_t );
	added_bytes += 4;

	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,ontology_name,ontology_name_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( ontology_name_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,service_desc,service_desc_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( service_desc_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	/* Send the buffer via the active socket */
	if ( packet_len > 0 )
	{
		ret = nota_stub_send_message( context, ( char* )buf, packet_len );
	}

	return ret;
}


int NoTA_System_ResourceMng_R01_01_DeleteEvent_req( struct context_pointer* context, uint32_t event_id )
{
	int ret = 0;
	uint8_t* buf = 0;
	uint16_t id = DELETEEVENT_REQ_SIGNAL_ID;
	int packet_len = 3;
	int partial_packet_sent = 0;
	int added_bytes = 0;

	/* Calculate packet size */
	packet_len += DELETEEVENT_REQ_PACKET_LENGTH;

	buf = &nota_send_buffer[0];

	/* Signal id */
	buf[added_bytes++]=TOKEN_SIGNAL16;
	NOTA_STUB_PACK16( &buf[added_bytes], id );
	added_bytes += 2;

	/* Packaging the values of the parameters into the buffer */
	buf[added_bytes++] = TOKEN_UINT32_T;
	NOTA_STUB_PACK32( &buf[added_bytes], event_id );
	added_bytes += 4;

	/* Send the buffer via the active socket */
	if ( packet_len > 0 )
	{
		ret = nota_stub_send_message( context, ( char* )buf, packet_len );
	}

	return ret;
}


static int NoTA_System_ResourceMng_R01_01_Register_cnf_parse( struct context_pointer* context, struct token* tokens, int tokens_count )
{
	int ret = 0;

	NOTA_STUB_ASSERT( tokens_count == REGISTER_CNF_TOKEN_NUMBER );

	/* Validate tokens */
	if ( tokens[0].type != TOKEN_UINT32_T )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( tokens[1].type != TOKEN_SID_T )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( !( ( tokens[2].type == TOKEN_BDATA8 ) || ( tokens[2].type == TOKEN_BDATA16 ) || ( tokens[2].type == TOKEN_NULL ) ) )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( !( ( tokens[3].type == TOKEN_BDATA8 ) || ( tokens[3].type == TOKEN_BDATA16 ) || ( tokens[3].type == TOKEN_NULL ) ) )
	{
		ret = -1;
		goto finishparsing;
	}

	/* Allocate memory for variables */

	/* Unpack values from the tokens into variables */
 
	/* Call user implemented process method */
	NoTA_System_ResourceMng_R01_01_Register_cnf_process( context, ( status_t )tokens[0].data.uint32_t, tokens[1].data.sid_t, tokens[2].type == TOKEN_NULL ? NULL : tokens[2].data.bdata.ptr, tokens[2].type == TOKEN_NULL ? 0 : tokens[2].data.bdata.len, tokens[3].type == TOKEN_NULL ? NULL : tokens[3].data.bdata.ptr, tokens[3].type == TOKEN_NULL ? 0 : tokens[3].data.bdata.len );

	/* Postprocess release temporary allocated memory */

	/* Handle possible errors */
finishparsing:

	return ret;
}

static int NoTA_System_ResourceMng_R01_01_Deregister_cnf_parse( struct context_pointer* context, struct token* tokens, int tokens_count )
{
	int ret = 0;

	NOTA_STUB_ASSERT( tokens_count == DEREGISTER_CNF_TOKEN_NUMBER );

	/* Validate tokens */
	if ( tokens[0].type != TOKEN_UINT32_T )
	{
		ret = -1;
		goto finishparsing;
	}

	/* Allocate memory for variables */

	/* Unpack values from the tokens into variables */
 
	/* Call user implemented process method */
	NoTA_System_ResourceMng_R01_01_Deregister_cnf_process( context, ( status_t )tokens[0].data.uint32_t );

	/* Postprocess release temporary allocated memory */

	/* Handle possible errors */
finishparsing:

	return ret;
}

static int NoTA_System_ResourceMng_R01_01_Challenge_ind_parse( struct context_pointer* context, struct token* tokens, int tokens_count )
{
	int ret = 0;

	NOTA_STUB_ASSERT( tokens_count == CHALLENGE_IND_TOKEN_NUMBER );

	/* Validate tokens */
	if ( !( ( tokens[0].type == TOKEN_BDATA8 ) || ( tokens[0].type == TOKEN_BDATA16 ) || ( tokens[0].type == TOKEN_NULL ) ) )
	{
		ret = -1;
		goto finishparsing;
	}

	/* Allocate memory for variables */

	/* Unpack values from the tokens into variables */
 
	/* Call user implemented process method */
	NoTA_System_ResourceMng_R01_01_Challenge_ind_process( context, tokens[0].type == TOKEN_NULL ? NULL : tokens[0].data.bdata.ptr, tokens[0].type == TOKEN_NULL ? 0 : tokens[0].data.bdata.len );

	/* Postprocess release temporary allocated memory */

	/* Handle possible errors */
finishparsing:

	return ret;
}

static int NoTA_System_ResourceMng_R01_01_ResolveService_cnf_parse( struct context_pointer* context, struct token* tokens, int tokens_count )
{
	int ret = 0;

	NOTA_STUB_ASSERT( tokens_count == RESOLVESERVICE_CNF_TOKEN_NUMBER );

	/* Validate tokens */
	if ( tokens[0].type != TOKEN_UINT32_T )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( tokens[1].type != TOKEN_SID_T )
	{
		ret = -1;
		goto finishparsing;
	}

	/* Allocate memory for variables */

	/* Unpack values from the tokens into variables */
 
	/* Call user implemented process method */
	NoTA_System_ResourceMng_R01_01_ResolveService_cnf_process( context, ( status_t )tokens[0].data.uint32_t, tokens[1].data.sid_t );

	/* Postprocess release temporary allocated memory */

	/* Handle possible errors */
finishparsing:

	return ret;
}

static int NoTA_System_ResourceMng_R01_01_ListOfServices_cnf_parse( struct context_pointer* context, struct token* tokens, int tokens_count )
{
	int i0;
	int ret = 0;
	servicelist_t* value1 = 0;

	NOTA_STUB_ASSERT( tokens_count == LISTOFSERVICES_CNF_TOKEN_NUMBER );

	/* Validate tokens */
	if ( tokens[0].type != TOKEN_LIST_START )
	{
		ret = -1;
		goto finishparsing;
	}
	for ( i0 = 0; i0 < tokens[0].data.list.token_count; ++i0 )
	{
		if ( !( tokens[0].data.list.tokens[i0].type == TOKEN_BDATA8 || tokens[0].data.list.tokens[i0].type == TOKEN_BDATA16 || tokens[0].data.list.tokens[i0].type == TOKEN_NULL ))
		{
			ret = -1;
			goto finishparsing;
		}
	}

	/* Allocate memory for variables */
	value1 = ( servicelist_t* )NOTA_STUB_ALLOCATE_MEMORY( sizeof( servicelist_t ) );
	if ( !value1 )
	{
		ret = -1;
		goto finishparsing;
	}

	value1->service_desc_count = tokens[0].data.list.token_count;
	value1->service_desc = ( uint8_t** )NOTA_STUB_ALLOCATE_MEMORY( sizeof( uint8_t* ) * value1->service_desc_count );
	if ( !value1->service_desc )
	{
		ret = -1;
		NOTA_STUB_FREE_MEMORY( value1 );
		value1 = NULL;
		goto finishparsing;
	}

	value1->service_desc_len = ( uint16_t* )NOTA_STUB_ALLOCATE_MEMORY( sizeof( uint16_t ) * value1->service_desc_count );
	if ( !value1->service_desc_len )
	{
		ret = -1;
		NOTA_STUB_FREE_MEMORY( value1->service_desc );
		value1->service_desc = NULL;
		NOTA_STUB_FREE_MEMORY( value1 );
		value1 = NULL;
		goto finishparsing;
	}


	/* Unpack values from the tokens into variables */
 	for ( i0 = 0; i0 < tokens[0].data.list.token_count; ++i0 )
	{
		value1->service_desc[i0] = tokens[0].data.list.tokens[i0].type == TOKEN_NULL ? NULL : tokens[0].data.list.tokens[i0].data.bdata.ptr;
		value1->service_desc_len[i0] = tokens[0].data.list.tokens[i0].type == TOKEN_NULL ? 0 : tokens[0].data.list.tokens[i0].data.bdata.len;
	}

	/* Call user implemented process method */
	NoTA_System_ResourceMng_R01_01_ListOfServices_cnf_process( context, value1 );

	/* Postprocess release temporary allocated memory */
	if ( value1 )
	{
		if ( value1->service_desc )
		{
			NOTA_STUB_FREE_MEMORY( value1->service_desc );
		}
		if ( value1->service_desc_len )
		{
			NOTA_STUB_FREE_MEMORY( value1->service_desc_len );
		}
		NOTA_STUB_FREE_MEMORY( value1 );
	}

	/* Handle possible errors */
finishparsing:

	return ret;
}

static int NoTA_System_ResourceMng_R01_01_NewEvent_cnf_parse( struct context_pointer* context, struct token* tokens, int tokens_count )
{
	int ret = 0;

	NOTA_STUB_ASSERT( tokens_count == NEWEVENT_CNF_TOKEN_NUMBER );

	/* Validate tokens */
	if ( tokens[0].type != TOKEN_INT32_T )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( tokens[1].type != TOKEN_UINT32_T )
	{
		ret = -1;
		goto finishparsing;
	}

	/* Allocate memory for variables */

	/* Unpack values from the tokens into variables */
 
	/* Call user implemented process method */
	NoTA_System_ResourceMng_R01_01_NewEvent_cnf_process( context, tokens[0].data.int32_t, ( status_t )tokens[1].data.uint32_t );

	/* Postprocess release temporary allocated memory */

	/* Handle possible errors */
finishparsing:

	return ret;
}

static int NoTA_System_ResourceMng_R01_01_NewEvent_ind_parse( struct context_pointer* context, struct token* tokens, int tokens_count )
{
	int ret = 0;

	NOTA_STUB_ASSERT( tokens_count == NEWEVENT_IND_TOKEN_NUMBER );

	/* Validate tokens */
	if ( tokens[0].type != TOKEN_UINT32_T )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( tokens[1].type != TOKEN_INT32_T )
	{
		ret = -1;
		goto finishparsing;
	}

	/* Allocate memory for variables */

	/* Unpack values from the tokens into variables */
 
	/* Call user implemented process method */
	NoTA_System_ResourceMng_R01_01_NewEvent_ind_process( context, tokens[0].data.uint32_t, ( event_t )tokens[1].data.int32_t );

	/* Postprocess release temporary allocated memory */

	/* Handle possible errors */
finishparsing:

	return ret;
}

static int NoTA_System_ResourceMng_R01_01_DeleteEvent_cnf_parse( struct context_pointer* context, struct token* tokens, int tokens_count )
{
	int ret = 0;

	NOTA_STUB_ASSERT( tokens_count == DELETEEVENT_CNF_TOKEN_NUMBER );

	/* Validate tokens */
	if ( tokens[0].type != TOKEN_UINT32_T )
	{
		ret = -1;
		goto finishparsing;
	}

	/* Allocate memory for variables */

	/* Unpack values from the tokens into variables */
 
	/* Call user implemented process method */
	NoTA_System_ResourceMng_R01_01_DeleteEvent_cnf_process( context, ( status_t )tokens[0].data.uint32_t );

	/* Postprocess release temporary allocated memory */

	/* Handle possible errors */
finishparsing:

	return ret;
}

